require(MASS)
require(dplyr)

## data set up
sim=mvrnorm(n = 5000, c(3,3), matrix(c(1,0,0,1),2,2) )
plot(sim)
county=rep(1:1000,each=5)
topLeft=mvrnorm(n = 100, c(1,5), matrix(c(1,0,0,1),2,2) )
topLeft=mvrnorm(n = 500, c(1,5), matrix(c(1,0,0,1),2,2) )
topLeft=mvrnorm(n = 1000, c(1,5), matrix(c(1,0,0,1),2,2) )
sim2=sim
sim2[1:100,]=topLeft
sim2[1:500,]=topLeft
sim2[1:1000,]=topLeft
plot(sim2)

dataN=as.data.frame(cbind(sim2[,1],county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(sim2[,2],county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=sim2[,1]/numD
denomRatio=sim2[,2]/denomD
plot(numRatio,denomRatio)

### quantile approach

r1=which(numRatio<quantile(numRatio,.25))
r2=which(denomRatio>quantile(denomRatio,.75))

resilient=intersect(r1,r2)
resilientCounties=unique(county[resilient])

s1=which(numRatio>quantile(numRatio,.75))
s2=which(denomRatio<quantile(denomRatio,.25))

sensitive=intersect(s1,s2)
sensitiveCounties=unique(county[sensitive])

length(intersect(resilientCounties,1:20)) ## 18
length(intersect(sensitiveCounties,1:20)) ## 1
length(intersect(resilientCounties,1:50)) ## 34
length(intersect(sensitiveCounties,1:50)) ## 4
length(intersect(resilientCounties,1:100)) ## 64
length(intersect(sensitiveCounties,1:100)) ##7

#### clustering

k <- 2
kmeans.raw <- kmeans(cbind(numRatio,denomRatio), centers=k)
kmeans.raw2 <- kmeans(sim2, centers=k)

plot(numRatio,denomRatio,col=as.factor(kmeans.raw$cluster))
plot(sim2,col=as.factor(kmeans.raw$cluster))
points(sim2[which(kmeans.raw$cluster==1),],col="black",pch=19)

## nope, better second time around, worse third time
plot(numRatio,denomRatio,col=as.factor(kmeans.raw2$cluster))
plot(sim2,col=as.factor(kmeans.raw2$cluster))
points(sim2[which(kmeans.raw2$cluster==2),],col="red",pch=19)

## Is the problem that I am giving each county multiple "time steps". Aggregate counties?

### Empirical Copulae

require(RColorBrewer)
par(mfrow=c(1,2))

smoothScatter(sim2,colramp=rbPal,xlim=c(-3,7),ylim=c(0,8))
smoothScatter(sim,colramp=rbPal,xlim=c(-3,7),ylim=c(0,8))

## can visually see the difference (before and after resilient counties added)
## maybe do some kind of bootstrapping to find "unexpected clusters"?

plot(ecdf(sim2[,1]))
plot(ecdf(sim2[,2]))

plot(ecdf(numRatio))
plot(ecdf(denomRatio))

u=sim2[,1]
v=sim2[,2]

u=numRatio
v=denomRatio

f <- ecdf(u) 
x<- u
y <- f(x)  # values of ecdf for number of packets in each second

y1=y

f <- ecdf(v) 
x <- v
y <- f(x)  # values of ecdf for each total bytes per second

y2=y


f <- ecdf(u) 
a1 <- u
b1 <- f(a1)

f <- ecdf(v) 
c1 <- v
d1 <- f(c1)

plot(y1,y2)
rbPal <- colorRampPalette(c(brewer.pal(9, "OrRd"),"black"))
smoothScatter(y1,y2,colramp=rbPal)
## doesn't look like much here, 
## but I think with some real data, we will see some more interesting patterns


