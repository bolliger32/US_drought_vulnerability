## runningAllModels.R
## Run all combinations of predictor and response variables in our model
## Write interaction coefficients for each model for use in the second stage
## Inputs: data_combined.csv
## Outputs: csv files to the coefficients folder, file for each combination
## Author: Sara Stoudt
## Date: 4/16/16
## Edited: Andy Hultgren, 4/27/16

require(parallel)
require(lfe)
require(plyr)

numCores=detectCores()
if(numCores==1){
  numCoresToUse=1
}else{
    numCoresToUse=numCores-2
  }

#setwd("C:/Users/Andy/Documents/ARE/Classes/z - DS421 - Stats 261/gitrepo/US_drought_vulnerability")
combined<-read.csv("data/data_combined.csv")
names(combined)

response<-c(6,9,12,24)
predictor<-c(13:15)
response2<-c(25:27)
response3<-c(6,12,24:27)

options=expand.grid(response,predictor)
options=expand.grid(response2,predictor)
options=expand.grid(response3,predictor)

stateID=length(unique(combined$STATEFP10))
states=unique(combined$STATEFP10) 

forParallelMod_ABTS=function(i,x,y){
  sub=subset(combined,STATEFP10==states[i])
  #sub=na.omit(subset(combined,STATEFP10==states[i]))
  sub$GISJOIN=as.character(sub$GISJOIN)
  sub$GISJOIN.FAC <- as.factor(sub$GISJOIN)
  sub[,y]=as.numeric(as.character(sub[,y]))
  sub[,x]=as.numeric(as.character(sub[,x]))

  if (all(is.na(sub[,y])) | all(is.na(sub[,x]))) {
    # Either all x's or all y's are NA's. 
    # This will generate an error, so return NA's and break.
    countyIDs <- unique(sub$GISJOIN)
    na.vec <- rep(NA,length(countyIDs))
    toReturn <- data.frame(countyIDs, na.vec, na.vec)
    names(toReturn)=c("countyID",paste("coeff","r",y,"p",x,sep="_"),paste("stdErr","r",y,"p",x,sep="_"))
    return(toReturn)
    break
  }
  
  #if(i==9){
  if(length(unique(sub$GISJOIN))==1){
    mod_ABTS=lm(sub[,y]~sub[,x]+sub$year) 
    toReturn=c() ## no interaction term allowed?
  }else if(length(unique(sub$GISJOIN))==0){
    toReturn=c()
  }else{
      # see updated felm() call below; 
      # the point estimates the coefficients of interest are the same,
      # but the felm() call clusters standard errors at the county level. 
      #mod_ABTS=lm(sub[,y]~sub[,x]*as.factor(sub$GISJOIN)+sub$year*as.factor(sub$GISJOIN)-sub$year-sub[,x]+as.factor(sub$year)-1) 
    # Year fixed effects (by state; i.e. state-by-year), county fixed effects, and county-level clustered standard errors.
    yname <- colnames(sub)[y]
    xname <- colnames(sub)[x]
    formula <- paste(yname, " ~ ", xname, ":GISJOIN.FAC + year:GISJOIN.FAC  | year + GISJOIN.FAC | 0 | GISJOIN.FAC", sep="")
    mod_ABTS <- felm( as.formula(formula), data=sub) #proposed change
    #browser()
    ## need to confirm that the "intercept" is the gamma term we want
    
    ## I think the coefficients we care about are the interaction between county and drought?
    ## alpha are just the per county
    ## beta have both drought and county
    coeff=coefficients(mod_ABTS)
    std.errors <- summary(mod_ABTS)$coefficients[,2]
    num=length(names(coeff))
    
    # Original code, modified below for new variable names
    #startVal=tail((1:num)[grepl("year)2",names(coeff))],1)+1
    #countyID=t(do.call(cbind,strsplit(names(coeff)[startVal:length(coeff)],")")))[,2]
    #stopVal=head(which(nchar(countyID)>8),1)
    #countyID=countyID[1:(stopVal-1)]
    
    countyID <- ldply(strsplit(names(coeff), ':'))
    countyID <- countyID[countyID$V1 == xname,2]
    countyID <- ldply(strsplit(countyID, 'FAC'))[2]
    number.of.coeffs <- nrow(countyID)
    toReturn=as.data.frame(cbind(countyID,unname(coeff[1:number.of.coeffs]), unname(std.errors[1:number.of.coeffs])))
    
    ## get reference interaction
    #http://www.r-bloggers.com/using-and-interpreting-different-contrasts-in-linear-models-in-r/
   # referenceLevel=setdiff(unique(sub$GISJOIN),countyID)
    #referenceLevelCoeff=coeff[2]-sum(coeff[(which(names(coeff)=="sub$year")+1):length(coeff)])
    
   # ORIGINAL toReturn definition
    #toReturn=as.data.frame(cbind(countyID,unname(coeff[startVal:(stopVal+startVal-2)])))
    
    #toReturn=as.data.frame(cbind(c(referenceLevel,countyID),c(referenceLevelCoeff,unname(coeff[(which(names(coeff)=="sub$year")+1):length(coeff)]))))
    names(toReturn)=c("countyID",paste("coeff","r",y,"p",x,sep="_"),paste("stdErr","r",y,"p",x,sep="_"))
    #toReturn$coeff=as.numeric(as.character(toReturn$coeff))
  }
  

  return(toReturn)
}

names(combined)

combined$unemploymentRate=as.character(combined$unemploymentRate)
combined$unemploymentRate[which(combined$unemploymentRate=="N.A.")]=NA
combined$unemploymentRate=as.numeric(combined$unemploymentRate)


#for(r in c(1:nrow(options))[-c(2,6,10)]){
for(r in 1:nrow(options) ){
  #modelABTS=mclapply(cbind(1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1],mc.cores=numCoresToUse)
  modelABTS=suppressWarnings(lapply(cbind(1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1]))
  combineAll=do.call(rbind,modelABTS)
  write.csv(combineAll,paste("results/coefficients_stage1/","modelABTS_","r",options[r,1],"p",options[r,2],".csv",sep=""),row.names=F)
  print(r)
} # r=2 error, 6,10 warning (these all involve 9, just remove)

## NOW HAVE ALL BUT DC


# For local testing
#setwd("C:/Users/Andy/Documents/ARE/Classes/z - DS421 - Stats 261/gitrepo/US_drought_vulnerability")
#numCoresToUse=1
#x=options[r,2]
#y=options[r,1]
#i = 5 #California
#tapply(sub$corn_yield, sub$GISJOIN, mean, na.rm=TRUE) #mean of yield by county

#for (i in 1:stateID) {
#  suppressWarnings(modelABTS <- forParallelMod_ABTS(i=i,x=options[r,2],y=options[r,1]))
#}
#subTest=subset(combined,STATEFP10==states[6])

#modelABTS=lapply((1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1])
