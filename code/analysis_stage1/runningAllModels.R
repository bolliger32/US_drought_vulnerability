## runningAllModels.R
## Run all combinations of predictor and response variables in our model
## Write interaction coefficients for each model for use in the second stage
## Inputs: data_combined.csv
## Outputs: csv files to the coefficients folder, file for each combination
## Author: Sara Stoudt
## Date: 4/16/16
## Edited: Andy Hultgren, 4/27/16

require(parallel)
require(lfe)
require(plyr)

numCores=detectCores()
if(numCores==1){
  numCoresToUse=1
}else{
  numCoresToUse=numCores-2
}

combined<-read.csv("../data/data_combined.csv")
names(combined)


predictor<-c(13:15)
response3<-c(6,12,24:27)


options=expand.grid(response3,predictor)

stateID=length(unique(combined$STATEFP10))
states=unique(combined$STATEFP10) 

forParallelMod_ABTS=function(i,x,y){
  sub=subset(combined,STATEFP10==states[i])
  sub$GISJOIN=as.character(sub$GISJOIN)
  sub$GISJOIN.FAC <- as.factor(sub$GISJOIN)
  sub[,y]=as.numeric(as.character(sub[,y]))
  sub[,x]=as.numeric(as.character(sub[,x]))
  
  if (all(is.na(sub[,y])) | all(is.na(sub[,x]))) {
    # Either all x's or all y's are NA's. 
    # This will generate an error, so return NA's and break.
    countyIDs <- unique(sub$GISJOIN)
    na.vec <- rep(NA,length(countyIDs))
    toReturn <- data.frame(countyIDs, na.vec, na.vec)
    names(toReturn)=c("countyID",paste("coeff","r",y,"p",x,sep="_"),paste("stdErr","r",y,"p",x,sep="_"))
    return(toReturn)
    break
  }
  

  if(length(unique(sub$GISJOIN))==1){
    mod_ABTS=lm(sub[,y]~sub[,x]+sub$year) 
    toReturn=c() ## no interaction term allowed?
  }else if(length(unique(sub$GISJOIN))==0){
    toReturn=c()
  }else{
    # see updated felm() call below; 
    # the point estimates the coefficients of interest are the same,
    # but the felm() call clusters standard errors at the county level. 
    #mod_ABTS=lm(sub[,y]~sub[,x]*as.factor(sub$GISJOIN)+sub$year*as.factor(sub$GISJOIN)-sub$year-sub[,x]+as.factor(sub$year)-1) 
    # Year fixed effects (by state; i.e. state-by-year), county fixed effects, and county-level clustered standard errors.
    yname <- colnames(sub)[y]
    xname <- colnames(sub)[x]
    formula <- paste(yname, " ~ ", xname, ":GISJOIN.FAC + year:GISJOIN.FAC  | year + GISJOIN.FAC | 0 | GISJOIN.FAC", sep="")
    mod_ABTS <- felm( as.formula(formula), data=sub) #proposed change
    
    coeff=coefficients(mod_ABTS)
    std.errors <- summary(mod_ABTS)$coefficients[,2]
    num=length(names(coeff))
    
  
    
    countyID <- ldply(strsplit(names(coeff), ':'))
    countyID <- countyID[countyID$V1 == xname,2]
    countyID <- ldply(strsplit(countyID, 'FAC'))[2]
    number.of.coeffs <- nrow(countyID)
    toReturn=as.data.frame(cbind(countyID,unname(coeff[1:number.of.coeffs]), unname(std.errors[1:number.of.coeffs])))
    
    
    names(toReturn)=c("countyID",paste("coeff","r",y,"p",x,sep="_"),paste("stdErr","r",y,"p",x,sep="_"))
  }
  
  
  return(toReturn)
}

names(combined)

combined$unemploymentRate=as.character(combined$unemploymentRate)
combined$unemploymentRate[which(combined$unemploymentRate=="N.A.")]=NA
combined$unemploymentRate=as.numeric(combined$unemploymentRate)



for(r in 1:nrow(options) ){
  #modelABTS=mclapply(cbind(1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1],mc.cores=numCoresToUse)
  modelABTS=suppressWarnings(lapply(cbind(1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1]))
  combineAll=do.call(rbind,modelABTS)
  write.csv(combineAll,paste("../results/coefficients_stage1/","modelABTS_","r",options[r,1],"p",options[r,2],".csv",sep=""),row.names=F)
  print(r)
} 

## Note: Works on Andy's computer (PC), but not Sara's (Mac). 