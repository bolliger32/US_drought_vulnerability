## runningAllModels.R
## Run all combinations of predictor and response variables in our model
## Write interaction coefficients for each model for use in the second stage
## Inputs: data_combined.csv
## Outputs: csv files to the coefficients folder, file for each combination
## Author: Sara Stoudt
## Date: 4/16/16

require(parallel)

numCores=detectCores()
if(numCores==1){
  numCoresToUse=1
}else{
    numCoresToUse=numCores-2
  }


combined<-read.csv("data/data_combined.csv")
names(combined)

response<-c(6,9,12,24)
predictor<-c(13:15)
response2<-c(25:27)

options=expand.grid(response,predictor)
options=expand.grid(response2,predictor)

stateID=length(unique(combined$STATEFP10))
states=unique(combined$STATEFP10)

forParallelMod_ABTS=function(i,x,y){
  sub=subset(combined,STATEFP10==states[i])
  #sub=na.omit(subset(combined,STATEFP10==states[i]))
  sub$GISJOIN=as.character(sub$GISJOIN)
  sub[,y]=as.numeric(as.character(sub[,y]))
  sub[,x]=as.numeric(as.character(sub[,x]))
  #if(i==9){
  if(length(unique(sub$GISJOIN))==1){
    mod_ABTS=lm(sub[,y]~sub[,x]+sub$year) 
    toReturn=c() ## no interaction term allowed?
  }else if(length(unique(sub$GISJOIN))==0){
    toReturn=c()
  }else{
    
    mod_ABTS=lm(sub[,y]~sub[,x]*as.factor(sub$GISJOIN)+sub$year) 
    # Year fixed effects (by state; i.e. state-by-year) and county-level clustered standard errors.
    #mod_ABTS=felm((sub[,y]~sub[,x]*as.factor(sub$GISJOIN)+sub$year*as.factor(sub$GISJOIN)),sub$year,0,sub$GISJOIN) #proposed change
    ## need to confirm that the "intercept" is the gamma term we want
    
    ## I think the coefficients we care about are the interaction between county and drought?
    ## alpha are just the per county
    ## beta have both drought and county
    coeff=coefficients(mod_ABTS)
    countyID=t(do.call(cbind,strsplit(names(coeff[(which(names(coeff)=="sub$year")+1):length(coeff)]),")")))[,2]
    
    ## get reference interaction
    #http://www.r-bloggers.com/using-and-interpreting-different-contrasts-in-linear-models-in-r/
    referenceLevel=setdiff(unique(sub$GISJOIN),countyID)
    referenceLevelCoeff=coeff[2]-sum(coeff[(which(names(coeff)=="sub$year")+1):length(coeff)])
    
    
    toReturn=as.data.frame(cbind(c(referenceLevel,countyID),c(referenceLevelCoeff,unname(coeff[(which(names(coeff)=="sub$year")+1):length(coeff)]))))
    names(toReturn)=c("countyID",paste("coeff","r",y,"p",x,sep="_"))
    toReturn$coeff=as.numeric(as.character(toReturn$coeff))
  }
  

  return(toReturn)
}

names(combined)

combined$unemploymentRate=as.character(combined$unemploymentRate)
combined$unemploymentRate[which(combined$unemploymentRate=="N.A.")]=NA
combined$unemploymentRate=as.numeric(combined$unemploymentRate)


#for(r in c(1:nrow(options))[-c(2,6,10)]){
for(r in 1:nrow(options) ){
modelABTS=mclapply(cbind(1:stateID),FUN=forParallelMod_ABTS,x=options[r,2],y=options[r,1],mc.cores=numCoresToUse)
combineAll=do.call(rbind,modelABTS)
write.csv(combineAll,paste("code/analysis_stage1/coefficients/","modelABTS_","r",options[r,1],"p",options[r,2],".csv",sep=""),row.names=F)
print(r)
} # r=2 error, 6,10 warning (these all involve 9, just remove)

## NOW HAVE ALL BUT DC

#9,13
#9,14
#9,15
sum(is.na(combined[,9]))/nrow(combined) #90% missing, just leave out
