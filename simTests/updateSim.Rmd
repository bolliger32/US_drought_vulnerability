---
title: "New Simulation Approach"
author: "Sara Stoudt"
date: "March 25, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Simulating from a Unit Square
```{r,message=FALSE}
num=runif(5000,0,1)
denom=runif(5000,0,1)

county=rep(1:1000,each=5)
#head(county)

require(dplyr)

dataN=as.data.frame(cbind(num,county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(denom,county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=num/numD
denomRatio=denom/denomD
```


```{r}
plot(num,denom)
plot(numRatio,denomRatio)


plot(numRatio/denomRatio)
plot((numRatio-1)/(denomRatio-1))
```

Highlighting "significant" entries in red.

```{r}
model1=lm(numRatio/denomRatio~I(as.factor(county)))
#summary(model1)

#which(summary(model1)$coeff[,4] < 0.01/5000)
summary(model1)$coeff[which(summary(model1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
## left hand side

plot(num,denom)
points(num[which(summary(model1)$coeff[,4] < 0.01/5000)]/denom[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
```

Highlighting "significant" entries in red.

```{r}
transformModel1=lm((numRatio-1)/(denomRatio-1)~I(as.factor(county)))

#which(summary(transformModel1)$coeff[,4] < 0.01/5000)
summary(transformModel1)$coeff[which(summary(transformModel1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
## more bottom left

plot(num,denom)
points(num[which(summary(transformModel1)$coeff[,4] < 0.01/5000)]/denom[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

```

Multivariate Gaussian- No Correlation

```{r,message=FALSE}
require(MASS)
sim=mvrnorm(n = 5000, c(3,3), matrix(c(1,0,0,1),2,2) )
plot(sim)

dataN=as.data.frame(cbind(sim[,1],county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(sim[,2],county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=sim[,1]/numD
denomRatio=sim[,2]/denomD
```

```{r}
plot(numRatio,denomRatio)

plot(numRatio/denomRatio)
plot((numRatio-1)/(denomRatio-1))

model1=lm(numRatio/denomRatio~I(as.factor(county)))
#summary(model1)


summary(model1)$coeff[which(summary(model1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
## finds ones in center

plot(sim)
points(sim[which(summary(model1)$coeff[,4] < 0.01/5000),],col="red",pch=19)
```

```{r}
transformModel1=lm((numRatio-1)/(denomRatio-1)~I(as.factor(county)))


summary(transformModel1)$coeff[which(summary(transformModel1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
## less central

plot(sim)
points(sim[which(summary(transformModel1)$coeff[,4] < 0.01/5000),],col="red",pch=19)
```

We are interested in pockets in top left and bottom right (resilient/sensitive)
Make that situation- make it easy, make consistent for certaint counties over "time".

```{r}
topLeft=mvrnorm(n = 100, c(1,5), matrix(c(1,0,0,1),2,2) ) ## represent resilient 
plot(sim)
points(topLeft,col="red")

## make first 20 counties resilient

sim2=sim
sim2[1:100,]=topLeft
plot(sim2)

dataN=as.data.frame(cbind(sim2[,1],county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(sim2[,2],county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=sim2[,1]/numD
denomRatio=sim2[,2]/denomD
```


```{r}
plot(numRatio,denomRatio)

plot(numRatio/denomRatio)
plot((numRatio-1)/(denomRatio-1))
```

```{r}
model1=lm(numRatio/denomRatio~I(as.factor(county)))
#summary(model1)


summary(model1)$coeff[which(summary(model1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(sim2)
points(sim2[which(summary(model1)$coeff[,4] < 0.01/5000),],col="red",pch=19)
```

```{r}
transformModel1=lm((numRatio-1)/(denomRatio-1)~I(as.factor(county)))

summary(transformModel1)$coeff[which(summary(transformModel1)$coeff[,4] < 0.01/5000)
,1] 

plot(numRatio,denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)
],denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)
],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)
]/denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)
],col="red",pch=19)

plot(sim2)
points(sim2[which(summary(transformModel1)$coeff[,4] < 0.01/5000),],col="red",pch=19)

```

No real difference- should be symmetric bottom right- check

```{r}
bottomRight=mvrnorm(n = 100, c(5,1), matrix(c(1,0,0,1),2,2) ) ## represent resilient 
plot(sim)
points(bottomRight,col="red")

## make first 20 counties resilient

sim2=sim
sim2[1:100,]=bottomRight
#plot(sim2)

dataN=as.data.frame(cbind(sim2[,1],county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(sim2[,2],county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=sim2[,1]/numD
denomRatio=sim2[,2]/denomD
```

```{r}
plot(numRatio,denomRatio)

plot(numRatio/denomRatio)
plot((numRatio-1)/(denomRatio-1))
```

```{r}
model1=lm(numRatio/denomRatio~I(as.factor(county)))
#summary(model1)


summary(model1)$coeff[which(summary(model1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(sim2)
points(sim2[which(summary(model1)$coeff[,4] < 0.01/5000),1],sim2[which(summary(model1)$coeff[,4] < 0.01/5000),2],col="red",pch=19) 
## now we get some of the desired ones
```

```{r}
transformModel1=lm((numRatio-1)/(denomRatio-1)~I(as.factor(county)))


summary(transformModel1)$coeff[which(summary(transformModel1)$coeff[,4] < 0.01/5000),1] 

plot(numRatio,denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(sim2)
points(sim2[which(summary(transformModel1)$coeff[,4] < 0.01/5000),1],sim2[which(summary(transformModel1)$coeff[,4] < 0.01/5000),2],col="red",pch=19) 

```

Add Negative Correlation, even more resilience

```{r}
topLeft=mvrnorm(n = 100, c(1,5), matrix(c(1,-.6,-.6,1),2,2) ) ## represent resilient 
plot(sim)
points(topLeft,col="red")

sim2=sim
sim2[1:100,]=topLeft
plot(sim2)

dataN=as.data.frame(cbind(sim2[,1],county))
names(dataN)=c("value","county")
countyLevel <- group_by(dataN, county)
countyLevel   <- summarise(countyLevel, meanValN = mean(value))
head(countyLevel)
numD=unlist(rep(countyLevel[,2],each=5))

dataD=as.data.frame(cbind(sim2[,2],county))
names(dataD)=c("value","county")
countyLevel <- group_by(dataD, county)
countyLevel   <- summarise(countyLevel, meanValD = mean(value))
head(countyLevel)
denomD=unlist(rep(countyLevel[,2],each=5))

numRatio=sim2[,1]/numD
denomRatio=sim2[,2]/denomD
```

```{r}
plot(numRatio,denomRatio)

plot(numRatio/denomRatio)
plot((numRatio-1)/(denomRatio-1))
```

```{r}
model1=lm(numRatio/denomRatio~I(as.factor(county)))
#summary(model1)


summary(model1)$coeff[which(summary(model1)$coeff[,4] < 0.01/5000),1]

plot(numRatio,denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(model1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(model1)$coeff[,4] < 0.01/5000)],col="red",pch=19)
##middle and boundary (keeps an old one, eliminates another)

plot(sim2)
points(sim2[which(summary(model1)$coeff[,4] < 0.01/5000),],col="red",pch=19)
```

```{r}
transformModel1=lm((numRatio-1)/(denomRatio-1)~I(as.factor(county)))


summary(transformModel1)$coeff[which(summary(transformModel1)$coeff[,4] < 0.01/5000),1] ## same

plot(numRatio,denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(numRatio/denomRatio)
points(numRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)]/denomRatio[which(summary(transformModel1)$coeff[,4] < 0.01/5000)],col="red",pch=19)

plot(sim2)
points(sim2[which(summary(transformModel1)$coeff[,4] < 0.01/5000),],col="red",pch=19)
#plot(numRatio/denomRatio,ylim=c(-5,5))
#points(numRatio[1:100]/denomRatio[1:100],col="red")
#### 
```

Big picture: using the "statistically significantly" different counties is not **picking out** sensitive/resilient counties.

Upon re-reading the paper this is a bit ambiguous. They say they use ANOVA to find areas that are significantly different than the others but then use quantiles to identify resilient/sensitive counties.

Assuming high values of both numerator and denominator are bad this is what they do:

resilient: above the 3rd quartile in denominator (drought) and below the 1st quartile in numerator

sensitive: below the 1st quartile in denominator (drought) and above the 3rd quartile in denominator

This seems a bit arbitrary, but it seems like a reasonable start. 

Two other approaches:

-Clustering (we have a good idea of the number of clusters- diagonal, top left, bottom right)

-Empirical Copulae

I will continue these types of simulations, testing out different ways to pick out resilient/sensitive counties. Stay tuned...