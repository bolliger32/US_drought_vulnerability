library(sp)
library(maps)
library(maptools)

weatherStations<-read.csv("weatherStations.csv") 

# The single argument to this function, pointsDF, is a data.frame in which:
#   - column 1 contains the longitude in degrees (negative in the US)
#   - column 2 contains the latitude in degrees
#http://stackoverflow.com/questions/8751497/latitude-longitude-coordinates-to-state-code-in-r/8751965#8751965
latlong2state <- function(pointsDF) {
  # Prepare SpatialPolygons object with one SpatialPolygon
  # per state (plus DC, minus HI & AK)
  states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
  IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
  states_sp <- map2SpatialPolygons(states, IDs=IDs)#,
  # proj4string=CRS("+proj=longlat +datum=wgs84"))
  
  # Convert pointsDF to a SpatialPoints object 
  pointsSP <- SpatialPoints(pointsDF)#, 
  # proj4string=CRS("+proj=longlat +datum=wgs84"))
  
  # Use 'over' to get _indices_ of the Polygons object containing each point 
  indices <- over(pointsSP, states_sp)
  
  # Return the state names of the Polygons object containing each point
  stateNames <- sapply(states_sp@polygons, function(x) x@ID)
  stateNames[indices]
}

latlong2county <- function(pointsDF) {
  # Prepare SpatialPolygons object with one SpatialPolygon
  # per county
  counties <- map('county', fill=TRUE, col="transparent", plot=FALSE)
  IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
  counties_sp <- map2SpatialPolygons(counties, IDs=IDs)#,
  #proj4string=CRS("+proj=longlat +datum=wgs84"))
  
  # Convert pointsDF to a SpatialPoints object 
  pointsSP <- SpatialPoints(pointsDF)#, 
  #proj4string=CRS("+proj=longlat +datum=wgs84"))
  
  # Use 'over' to get _indices_ of the Polygons object containing each point 
  indices <- over(pointsSP, counties_sp)
  
  # Return the county names of the Polygons object containing each point
  countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
  countyNames[indices]
}

missing=unique(union(which(is.na(weatherStations$longitude)),which(is.na(weatherStations$latitude))))
weatherStations=weatherStations[-missing,] ## remove stations with missing values of lat long
weatherStations$state=latlong2state(weatherStations[,c("longitude","latitude")])
weatherStations$county=latlong2county(weatherStations[,c("longitude","latitude")])

caWeatherStations=subset(weatherStations,state=="california")
nrow(caWeatherStations)
map("state","california")
points(caWeatherStations$longitude, caWeatherStations$latitude,pch=19)


#http://stackoverflow.com/questions/9441436/ggplot-centered-names-on-a-map
county_poly <- map("county", "ca", plot=FALSE, fill = TRUE)
county_centroids <- maps:::apply.polygon(county_poly, maps:::centroid.polygon)

countyCenter=do.call("rbind", county_centroids)



require(weatherData)
years=seq(1999,2014,1)
for(i in 1:length(years)){
  
  isData=unlist(lapply(1:nrow(caWeatherStations),function(x){checkSummarizedDataAvailability(caWeatherStations$code[x],paste(years[i],"-01-01",sep=""),paste(years[i],"-12-31",sep=""))}))
  
  getData=lapply((1:nrow(caWeatherStations))[which(isData==1)],function(x){
    cbind(getSummarizedWeather(caWeatherStations$code[x],paste(years[i],"-01-01",sep=""),
                               paste(years[i],"-12-31",sep=""),opt_custom_columns=T,
                               custom_columns=c(2,3,4,8,9,10,17,18,20)),x,years[i])})
  
  save(getData,file=paste("caMonthlyWeather",years[i],".RData",sep=""))
  
} ## this will take awhile, should use noaa data when we do this for real


meanTempPerYearPerStationFull=list(length(years))
years=seq(1999,2014,1)
for(i in 1:length(years)){
  
  
  load(file=paste("caMonthlyWeather",years[i],".RData",sep=""))
  
  if(years[i]==2006){ ## freak thing happening
    useThis=c(1:length(getData))
    useThis=useThis[-85]
    meanTempPerYearPerStation=unlist(lapply(useThis,function(x){c(mean(getData[[x]][,3],na.rm=T),getData[[x]][1,11])}))
    
  }else{
    meanTempPerYearPerStation=unlist(lapply(1:length(getData),function(x){c(mean(getData[[x]][,3],na.rm=T),getData[[x]][1,11])}))
  }
  meanTempPerYearPerStationFull[[i]]= cbind(meanTempPerYearPerStation[seq(1,length(meanTempPerYearPerStation),2)],meanTempPerYearPerStation[seq(2,length(meanTempPerYearPerStation),2)],years[i])
  
}



save(meanTempPerYearPerStationFull,file="meanTempPerYearPerStation.Rdata")


require(fields)

## which station to use for each county for each year
closest=c()
for(i in 1:length(years)){
  distances=rdist.earth(
    matrix(c(countyCenter[,1],countyCenter[,2]), ncol=2),
    matrix(cbind(as.numeric(caWeatherStations[meanTempPerYearPerStationFull[[i]][,2],"longitude"]),
                 as.numeric(caWeatherStations[meanTempPerYearPerStationFull[[i]][,2],"latitude"])), ncol=2),
    miles=FALSE, R=6371) # not Euclidean distance, Great Circle Distance
  
  closest=cbind(closest,meanTempPerYearPerStationFull[[i]][,2][apply(distances,1,which.min)]) 
}

Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

whichStationUse=apply(closest,1,Mode)

## mode of closest across years to match to mean overall

is.integer0 <- function(x)
{
  is.integer(x) && length(x) == 0L
}

findMean=function(x,i){
  
  if(is.integer0(which(meanTempPerYearPerStationFull[[i]][,2]==x))){
    NA
  }else{
    meanTempPerYearPerStationFull[[i]][which(meanTempPerYearPerStationFull[[i]][,2]==x),1]}
}

droughtIndexDenom=c()
for(i in 1:length(years)){
  
  droughtIndexDenom=cbind(droughtIndexDenom,unlist(lapply(closest[,i],findMean,i)))
  
}

## will need to fill in with second closest, but for now this is fine


## flatten list

flatMeanPerYearPerStationFull=do.call("rbind", meanTempPerYearPerStationFull)
## aggregate by station id 


flatMeanPerYearPerStationFull=as.data.frame(flatMeanPerYearPerStationFull)
names(flatMeanPerYearPerStationFull)=c("meanTemp","stationID","year")
require(dplyr)

by_station <- group_by(flatMeanPerYearPerStationFull, stationID)
overallMean <- summarise(by_station,
                         meanOverall = mean(meanTemp, na.rm = TRUE)
)
overallMean
overallMean=as.data.frame(overallMean)
names(overallMean)


denomTemp=c()
for(k in 1:nrow(droughtIndexDenom)){
  denomTemp=rbind(denomTemp,overallMean[which(overallMean$stationID==whichStationUse[k]),2]/droughtIndexDenom[k,])
 
}

head(denomTemp)

hist(denomTemp)

plot(denomTemp[1,])
plot(denomTemp[2,])
plot(denomTemp[3,])
plot(denomTemp[4,]) ## evidence for increased resilience in some areas



rbPal <- colorRampPalette(c('blue','red'))

col<- rbPal(10)[as.numeric(cut(denomTemp[,16],breaks = 10))] # just in 2014
map("county","ca",fill=T,col=col)

col<- rbPal(10)[as.numeric(cut(apply(denomTemp,1,mean,na.rm=T),breaks = 10))] # mean overall the years
map("county","ca",fill=T,col=col)

## most sensitive: https://en.wikipedia.org/wiki/Trinity_County,_California
#https://en.wikipedia.org/wiki/Humboldt_County,_California
#https://en.wikipedia.org/wiki/Mono_County,_California
# rural areas
## most resilient: https://en.wikipedia.org/wiki/Tuolumne_County,_California
## LA

## this is just denom

dim(denomTemp)

index=numeratorMortality/denomTemp ## numeratorMortality from numerator file


par(mfrow=c(1,2))
col<- rbPal(10)[as.numeric(cut(index[,1],breaks = 10))]
map("county","ca",fill=T,col=col)

col<- rbPal(10)[as.numeric(cut(index[,16],breaks = 10))]
map("county","ca",fill=T,col=col) ## definitely some movement in resiliency over time


##
col<- rbPal(10)[as.numeric(cut(apply(index,1,mean),breaks = 10))]
map("county","ca",fill=T,col=col)
