### left to do
## get state info
## add multiple time series lines to compare different counties (2nd tab)
##   probably need a reset button
## match our county identifier to that of R maps

library(shiny)
library(maps)
library(RColorBrewer)
library(sp)
library(SDMTools)
library(maptools)

latlong2county <- function(pointsDF) {
  # Prepare SpatialPolygons object with one SpatialPolygon
  # per county
  counties <- map('county', fill=TRUE, col="transparent", plot=FALSE)
  IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
  counties_sp <- map2SpatialPolygons(counties, IDs=IDs,
                                     proj4string=CRS("+proj=longlat"))
  
  
  pointsSP <- SpatialPoints(pointsDF, 
                            proj4string=CRS("+proj=longlat"))
  
  # Use 'over' to get _indices_ of the Polygons object containing each point 
  indices <- over(pointsSP, counties_sp)
  
  # Return the county names of the Polygons object containing each point
  countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
  countyNames[indices]
}

data=read.csv("forShinyData.csv")

## note: order of the counties must be in the same order as R expects
## need to go between label in our data and this way of representing counties!!
ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
names(ordering)=c("county","order")
ordering$order=as.integer(as.character(ordering$order))
toOrder=merge(data,ordering,by.x="county",by.y="county",all.y=T)
data=toOrder[order(toOrder$order),]



shinyServer(function(input, output) {
  

  output$fullMap <- renderPlot({
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    #print(index)
    #print(Year)
    ofInterest=data[,c("county","year",index)]
   # print(ofInterest)
    #print(class(ofInterest$year))
    ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    cuts=factor(cut(ofInterest[,3],10))
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    
    labs <- levels(cuts)
    cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
          upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    
    Col=mypalette[cuts] 
    
    
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    
    
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10,2],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9,2],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8,2],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7,2],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6,2],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5,2],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4,2],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3,2],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2,2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1,2],2),cex=.75)
    
    
  })
  
  output$byState  <- renderPlot({

     st=input$state
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    
    ofInterest=data[,c("county","year","state",index)]
    ofInterest=subset(ofInterest,year==Year)

    cutsOverall=factor(cut(ofInterest[,4],10))

    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut(ofInterestS[,4],10))
   
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
   
  observe({
    if(is.null(input$plot_click$x)){return(NULL)}
    click <- c(input$plot_click$x, input$plot_click$y)
    latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    County=latlong2county(latlong)
    
    
    isolate({
      Year=input$y ## use to subset data
      index=input$indic ## use to subset data
      
      ofInterest=data[,c("county","year",index)]
      ofInterestC=subset(ofInterest,county==County)
      ofInterestC=ofInterestC[order(ofInterestC$year),]
      output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    })
  })
  })
  ##http://stackoverflow.com/questions/26890465/shiny-r-action-button-controls-reactive-elements
  ##http://stackoverflow.com/questions/28023342/interactive-plotting-in-shiny-using-mouse-clicks

  output$table <- renderTable({
    #data.frame(x=data())
  })
  output$table2 <- renderTable({
    #data.frame(x=data())
  })
  
})