### left to do
## get state info
## add multiple time series lines to compare different counties (2nd tab)
##   probably need a reset button
## match our county identifier to that of R maps

library(shiny)
library(maps)
library(RColorBrewer)
library(sp)
library(SDMTools)
library(maptools)
library(Hmisc)

latlong2county <- function(pointsDF) {
  # Prepare SpatialPolygons object with one SpatialPolygon
  # per county
  counties <- map('county', fill=TRUE, col="transparent", plot=FALSE)
  IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
  counties_sp <- map2SpatialPolygons(counties, IDs=IDs,
                                     proj4string=CRS("+proj=longlat"))
  
  
  pointsSP <- SpatialPoints(pointsDF, 
                            proj4string=CRS("+proj=longlat"))
  
  # Use 'over' to get _indices_ of the Polygons object containing each point 
  indices <- over(pointsSP, counties_sp)
  
  # Return the county names of the Polygons object containing each point
  countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
  countyNames[indices]
}

#data=read.csv("forShinyData.csv")
#data2=read.csv("forShinyData2.csv")
#data3=read.csv("forShinyData3.csv")
#data4=read.csv("forShinyData4.csv")
data=read.csv("newData/forShinyData.csv")
data2=read.csv("newData/forShinyData2.csv")
data3=read.csv("newData/forShinyData3.csv")
data4=read.csv("newData/forShinyData4.csv")
data5a=read.csv("newData/forShinyData5a.csv")
data5b=read.csv("newData/forShinyData5b.csv")
#data5a=read.csv("forShinyData5a.csv")
#data5b=read.csv("forShinyData5b.csv")
## note: order of the counties must be in the same order as R expects
## need to go between label in our data and this way of representing counties!!
ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
names(ordering)=c("county","order")
ordering$order=as.integer(as.character(ordering$order))
toOrder=merge(data,ordering,by.x="county",by.y="county",all.y=T)
data=toOrder[order(toOrder$order),]

toOrder2=merge(data2,ordering,by.x="county",by.y="county",all.y=T)
data2=toOrder2[order(toOrder2$order),]


toOrder3=merge(data3,ordering,by.x="county",by.y="county",all.y=T)
data3=toOrder3[order(toOrder3$order),]


shinyServer(function(input, output) {
  
  
  output$fullMap <- renderPlot({
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    #print(index)
    #print(Year)
    ofInterest=data[,c("county","year",index)]
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    ofInterest=subset(ofInterest,year==Year)
    
    ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
    names(ordering)=c("county","order")
    ordering$order=as.integer(as.character(ordering$order))
    toOrder=merge(ofInterest,ordering,by.x="county",by.y="county",all.y=T)
    #print(names(toOrder))
    ofInterest=toOrder[order(toOrder$order),]
    
    
    
    
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    #cuts=factor(cut2(ofInterest[,3],g=10))
    cutsF=factor(cut2(as.numeric(as.character(data[!is.na(data[,index]),index])),g=10))
    #print(unique(cutsF))
    intermediate=unlist(lapply(levels(cutsF),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    cutPoints[is.na(cutPoints)]=0-.Machine$double.eps
    #print(cutPoints)
    cuts=cut(ofInterest[,3],cutPoints)
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    
    labs <- levels(cutsF)
    #print(labs)
    #cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
    #     upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    
    #intermediate=unlist(lapply(levels(cuts),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    #intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    #cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    
    Col=mypalette[cuts] 
    Col[is.na(Col)]="purple"
    
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    
    
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1],2),cex=.75)
    
    
  })
  
  output$byState  <- renderPlot({
    
    
    st=input$state
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    
    ofInterest=data[,c("county","year","state",index)]
    ofInterest=subset(ofInterest,year==Year)
    
    cutsOverall=factor(cut2(ofInterest[,4],g=10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut2(ofInterestS[,4],g=10))
    
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      #cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
      #upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      #leg=cutPoints[,2]
      intermediate=unlist(lapply(levels(cutsOverall),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
      intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
      leg=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      # cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
      #                upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      intermediate=unlist(lapply(levels(cutsByState),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
      intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
      leg=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
      #leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
    
    observe({
      if(is.null(input$plot_click$x)){return(NULL)}
      click <- c(input$plot_click$x, input$plot_click$y)
      latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
      County=latlong2county(latlong)
      
      
      isolate({
        Year=input$y ## use to subset data
        index=input$indic ## use to subset data
        
        ofInterest=data[,c("county","year",index)]
        ofInterestC=subset(ofInterest,county==County)
        ofInterestC=ofInterestC[order(ofInterestC$year),]
        output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
      })
    })
  })
  ##http://stackoverflow.com/questions/26890465/shiny-r-action-button-controls-reactive-elements
  ##http://stackoverflow.com/questions/28023342/interactive-plotting-in-shiny-using-mouse-clicks
  
  output$fullMap2<- renderPlot({
    
    # par(mfrow=c(2,1))
    
    ##incorporate input$checkbox
    Predictor=input$predictor
    Response=input$response
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    #print(column)
    #print(names(data2))
    ofInterest=data2[,c(column,"county")]
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    #ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    
    ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
    names(ordering)=c("county","order")
    ordering$order=as.integer(as.character(ordering$order))
    toOrder=merge(ofInterest,ordering,by.x="county",by.y="county",all.y=T)
    #print(names(toOrder))
    ofInterest=toOrder[order(toOrder$order),]
    #print("here")
    cutsF=factor(cut2(data2[!is.na(data2[,column]),column],g=10))
    #print("here2")
    intermediate=unlist(lapply(levels(cutsF),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    #print("here3")
    intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    #print(class(ofInterest[,1]))
    #print(head(ofInterest[,1]))
    #print(names(ofInterest))
    cuts=cut(ofInterest[,2],cutPoints)
    
    #cuts=factor(cut2(ofInterest[,1],g=10))
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #print("here")
    labs <- levels(cutsF)
    # cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    # cutPoints=cbind(lower = as.numeric( sub("\\[[.+],.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("(^,)*,[(^))*]\\)", "\\1", labs) ))
    Col=mypalette[cuts] 
    Col[is.na(Col)]="purple"
   # print(unique(Col))
    #print(summary(ofInterest[,2]))
    
    intermediate=unlist(lapply(levels(cuts),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    # print(length(cutPoints))
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    #print(quantile(ofInterest[,1],seq(0,1,by=.1),na.rm=T))
    #print(dim(cutPoints))
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1],2),cex=.75)
    
    #print("here")
    
  })
  
  output$hist<-renderPlot({
    par(mfrow=c(1,2))
    
    Predictor=input$predictor
    Response=input$response
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    #print(column)
    #print(names(data2))
    ofInterest=data2[,c(column,"county")]
    hist(ofInterest[,1],main="First Stage Betas",xlab="")
    hist(log(ofInterest[,1]),xlab="",main="Log(First Stage Betas)")
  })
  
  output$hist2<-renderPlot({
    #par(mfrow=c(1,2))
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    #print(index)
    #print(Year)
    ofInterest=data[,c("county","year",index)]
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    ofInterest=subset(ofInterest,year==Year)
    hist(ofInterest[,3],main="First Stage Input",xlab="")
    #hist(log(ofInterest[,3]),xlab="",main="Log(First Stage Betas)")
  })
  
  output$hist3<-renderPlot({
    #par(mfrow=c(1,2))
    
    AGG=input$agg
    var=input$secStageVar
    
    ## means 3:11
    ## sd 12:18
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+11
    }
    
    # print(column)
    #  print(names(data3))
    ofInterest=data3[,c(column,1)]
    hist(ofInterest[,1],main="Second Stage Input",xlab="")
    #hist(log(ofInterest[,3]),xlab="",main="Log(First Stage Betas)")
  })
  
  
  output$hist4<-renderPlot({
    #par(mfrow=c(1,2))
    
    st=input$state
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    
    ofInterest=data[,c("county","year","state",index)]
    ofInterest=subset(ofInterest,year==Year)
    
    #cutsOverall=factor(cut2(ofInterest[,4],g=10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    #cutsByState=factor(cut2(ofInterestS[,4],g=10))
    hist(ofInterestS[,4],main="First Stage Input by State",xlab="")
    # hist(log(ofInterest[,4]),xlab="",main="Log(First Stage Betas by State)")
  })
  
  output$hist5<-renderPlot({
    par(mfrow=c(1,2))
    
    st=input$state2
    
    Predictor=input$predictor2
    Response=input$response2
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    
    ofInterest=data2[,c("county","state",column)]
    #ofInterest=subset(ofInterest,year==Year)
    
    #cutsOverall=factor(cut(ofInterest[,3],10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    #cutsByState=factor(cut(ofInterestS[,3],10))
    
    hist(ofInterestS[,3],main="First Stage Betas by State",xlab="")
    hist(log(ofInterestS[,3]),xlab="",main="Log(First Stage Betas by State)")
  })
  
  output$hist6<-renderPlot({
    #par(mfrow=c(1,2))
    st=input$state3
    
    AGG=input$agg2
    var=input$secStageVar2
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+11
    }
    
    
    ofInterest=data3[,c(column,1,2)]
    #ofInterest=subset(ofInterest,year==Year)
    
    #cutsOverall=factor(cut(ofInterest[,1],10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    #cutsByState=factor(cut(ofInterestS[,1],10))
    
    
    hist(ofInterestS[,1],main="Second Stage Inputs by State",xlab="")
    # hist(log(ofInterestS[,1]),xlab="",main="Log(First Stage Betas by State)")
  })
  
  output$byState2  <- renderPlot({
    
    ##incorporate input$checkbox
    
    st=input$state2
    
    Predictor=input$predictor2
    Response=input$response2
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    
    ofInterest=data2[,c("county","state",column)]
    #ofInterest=subset(ofInterest,year==Year)
    #print(dim(ofInterest))
    cutsOverall=factor(cut(ofInterest[,3],10))
    #print("here")
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    #print(st)
    #print(dim(ofInterestS))
    cutsByState=factor(cut(ofInterestS[,3],10))
    #print("here")
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant2==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
    # 
    # observe({
    #   if(is.null(input$plot_click$x)){return(NULL)}
    #   click <- c(input$plot_click$x, input$plot_click$y)
    #   latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    #   County=latlong2county(latlong)
    #   
    #   
    #   isolate({
    #     Year=input$y ## use to subset data
    #     index=input$indic ## use to subset data
    #     
    #     ofInterest=data[,c("county","year",index)]
    #     ofInterestC=subset(ofInterest,county==County)
    #     ofInterestC=ofInterestC[order(ofInterestC$year),]
    #     output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    #   })
    # })
  })
  
  
  output$fullMap3<- renderPlot({
    ##incorporate input$checkbox
    #Predictor=input$predictor
    #Response=input$response
    
    AGG=input$agg
    var=input$secStageVar
    
    ## means 3:18
    ## sd 19:34
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+11
    }
    
    # print(column)
    #  print(names(data3))
    ofInterest=data3[,c(column,1)]
    
    
    ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
    names(ordering)=c("county","order")
    ordering$order=as.integer(as.character(ordering$order))
    toOrder=merge(ofInterest,ordering,by.x="county",by.y="county",all.y=T)
    #print(names(toOrder))
    ofInterest=toOrder[order(toOrder$order),]
    cutsF=factor(cut2(data3[!is.na(data3[,column]),column],g=10))
    intermediate=unlist(lapply(levels(cutsF),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    #print("here")
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    #ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    #cuts=factor(cut2(ofInterest[,1],g=10))
    print(names(ofInterest))
    cuts=cut(ofInterest[,2],cutPoints)
    
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #print("here")
    labs <- levels(cuts)
    # cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    # cutPoints=cbind(lower = as.numeric( sub("\\[[.+],.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("(^,)*,[(^))*]\\)", "\\1", labs) ))
    Col=mypalette[cuts] 
    Col[is.na(Col)]="purple"
    
    
    #intermediate=unlist(lapply(levels(cuts),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    #intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    #cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    # print(length(cutPoints))
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    #print(quantile(ofInterest[,1],seq(0,1,by=.1),na.rm=T))
    #print(dim(cutPoints))
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1],2),cex=.75)
    
    #print("here")
  })
  
  
  
  output$byState3  <- renderPlot({
    
    ##incorporate input$checkbox
    
    st=input$state3
    
    AGG=input$agg2
    var=input$secStageVar2
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+11
    }
    
    
    ofInterest=data3[,c(column,1,2)]
    #ofInterest=subset(ofInterest,year==Year)
    
    cutsOverall=factor(cut(ofInterest[,1],10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut(ofInterestS[,1],10))
    
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant3==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
    # 
    # observe({
    #   if(is.null(input$plot_click$x)){return(NULL)}
    #   click <- c(input$plot_click$x, input$plot_click$y)
    #   latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    #   County=latlong2county(latlong)
    #   
    #   
    #   isolate({
    #     Year=input$y ## use to subset data
    #     index=input$indic ## use to subset data
    #     
    #     ofInterest=data[,c("county","year",index)]
    #     ofInterestC=subset(ofInterest,county==County)
    #     ofInterestC=ofInterestC[order(ofInterestC$year),]
    #     output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    #   })
    # })
  })
  
  output$corr<-renderPlot({
    
    
    
    Predictor=input$predictor4
    Response=input$response4
    secStage=input$secStageVar3 ## need to map to a number
    AGG=input$agg3
    # 
    #print(AGG)
    #21:29= mean
    #30:38= sd
    #1
    #2 
    
    
    if(AGG=="1"){
      index=20+as.numeric(as.character(secStage))
    }else{
      index=29+as.numeric(as.character(secStage))
    }
    indexN=names(data4)[index]
    #print(indexN)
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    ofInterest=data4[,c(column,indexN)]
    # ## need to merge data3 and data2 on county
    par(mfrow=c(1,2))
    plot(ofInterest[,1],ofInterest[,2],xlab="Beta Coefficients from Stage 1",ylab=indexN,main="")
    plot(ofInterest[,1],ofInterest[,2],xlab="Beta Coefficients from Stage 1",ylab=indexN,main="Zoomed In",xlim=c(-100,100))
  })
  
  
  
  
  output$table <- renderTable({
    data.frame(x=data())
    
    # if(input$msd=="1"){
    #   toUse=data5a
    # }else{
    #   toUse=data5b
    # }
    # 
    # 
    # Response=input$response3
    # Predictor=input$predictor3
    # column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    # 
    # coeffOfInterest=subset(toUse,Outcome==column)
    # 
    # #toDisplay=toUse[c(1:5),c(2:5)]
    # 
    # 
    # betterNames=c("Intercept","Proportion Age <5", "Proportion Age >65", "Proportion Hispanic", 
    #               "Proportion White","Proportion Male","Proportion Who Work in Farming or Ranching",
    #               "Average Household Water Bill", "Mean Household Income", 
    #               "Proportion of Households Who Own Their Own Home", "Water Usage",
    #               "Indicator: Is Rural")
    # coeffOfInterest$Predictors=betterNames
    # names(coeffOfInterest)[3:4]=c("Standard Error","P-Value")
    # data.frame(coeffOfInterest[,c(1:4)])
  })
  output$table2 <- renderTable({
    #data.frame(x=data())
  })
  output$table3 <- renderTable({
    #data.frame(x=data())
  })
  
})