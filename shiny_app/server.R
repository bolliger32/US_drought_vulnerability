### left to do
## get state info
## add multiple time series lines to compare different counties (2nd tab)
##   probably need a reset button
## match our county identifier to that of R maps

library(shiny)
library(maps)
library(RColorBrewer)
library(sp)
library(SDMTools)
library(maptools)
library(Hmisc)

latlong2county <- function(pointsDF) {
  # Prepare SpatialPolygons object with one SpatialPolygon
  # per county
  counties <- map('county', fill=TRUE, col="transparent", plot=FALSE)
  IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
  counties_sp <- map2SpatialPolygons(counties, IDs=IDs,
                                     proj4string=CRS("+proj=longlat"))
  
  
  pointsSP <- SpatialPoints(pointsDF, 
                            proj4string=CRS("+proj=longlat"))
  
  # Use 'over' to get _indices_ of the Polygons object containing each point 
  indices <- over(pointsSP, counties_sp)
  
  # Return the county names of the Polygons object containing each point
  countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
  countyNames[indices]
}

data=read.csv("forShinyData.csv")
data2=read.csv("forShinyData2.csv")
data3=read.csv("forShinyData3.csv")
## note: order of the counties must be in the same order as R expects
## need to go between label in our data and this way of representing counties!!
ordering=as.data.frame(cbind(map('county', plot=FALSE)$names,1:length(map('county', plot=FALSE)$names)))
names(ordering)=c("county","order")
ordering$order=as.integer(as.character(ordering$order))
toOrder=merge(data,ordering,by.x="county",by.y="county",all.y=T)
data=toOrder[order(toOrder$order),]

toOrder2=merge(data2,ordering,by.x="county",by.y="county",all.y=T)
data2=toOrder2[order(toOrder2$order),]


toOrder3=merge(data3,ordering,by.x="county",by.y="county",all.y=T)
data3=toOrder3[order(toOrder3$order),]


shinyServer(function(input, output) {
  

  output$fullMap <- renderPlot({
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    print(index)
    #print(Year)
    ofInterest=data[,c("county","year",index)]
    print(dim(ofInterest))
   # print(ofInterest)
    #print(class(ofInterest$year))
    ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    cuts=factor(cut(ofInterest[,3],10))
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    
    labs <- levels(cuts)
    cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
          upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    
    Col=mypalette[cuts] 
    
    
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    
    
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10,2],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9,2],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8,2],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7,2],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6,2],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5,2],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4,2],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3,2],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2,2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1,2],2),cex=.75)
    
    
  })
  
  output$byState  <- renderPlot({

     st=input$state
    
    Year=input$y ## use to subset data
    index=input$indic ## use to subset data
    
    ofInterest=data[,c("county","year","state",index)]
    ofInterest=subset(ofInterest,year==Year)

    cutsOverall=factor(cut(ofInterest[,4],10))

    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut(ofInterestS[,4],10))
   
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
   
  observe({
    if(is.null(input$plot_click$x)){return(NULL)}
    click <- c(input$plot_click$x, input$plot_click$y)
    latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    County=latlong2county(latlong)
    
    
    isolate({
      Year=input$y ## use to subset data
      index=input$indic ## use to subset data
      
      ofInterest=data[,c("county","year",index)]
      ofInterestC=subset(ofInterest,county==County)
      ofInterestC=ofInterestC[order(ofInterestC$year),]
      output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    })
  })
  })
  ##http://stackoverflow.com/questions/26890465/shiny-r-action-button-controls-reactive-elements
  ##http://stackoverflow.com/questions/28023342/interactive-plotting-in-shiny-using-mouse-clicks

  output$fullMap2<- renderPlot({
    ##incorporate input$checkbox
    Predictor=input$predictor
    Response=input$response
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    #print(column)
    #print(names(data2))
    ofInterest=data2[,c(column,"county")]
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    #ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    cuts=factor(cut2(ofInterest[,1],g=10))
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #print("here")
    labs <- levels(cuts)
    # cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    # cutPoints=cbind(lower = as.numeric( sub("\\[[.+],.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("(^,)*,[(^))*]\\)", "\\1", labs) ))
    Col=mypalette[cuts] 
    
  
    
intermediate=unlist(lapply(levels(cuts),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
   # print(length(cutPoints))
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
#print(quantile(ofInterest[,1],seq(0,1,by=.1),na.rm=T))
    #print(dim(cutPoints))
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1],2),cex=.75)
    
    #print("here")
  })
  
  
  output$byState2  <- renderPlot({
    
    ##incorporate input$checkbox
    
    st=input$state2
    
    Predictor=input$predictor2
    Response=input$response2
    
    column=paste("coeff_r_",Response,"_p_",Predictor,sep="")
    
    ofInterest=data2[,c("county","state",column)]
    #ofInterest=subset(ofInterest,year==Year)
    
    cutsOverall=factor(cut(ofInterest[,3],10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut(ofInterestS[,3],10))
    
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant2==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
    # 
    # observe({
    #   if(is.null(input$plot_click$x)){return(NULL)}
    #   click <- c(input$plot_click$x, input$plot_click$y)
    #   latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    #   County=latlong2county(latlong)
    #   
    #   
    #   isolate({
    #     Year=input$y ## use to subset data
    #     index=input$indic ## use to subset data
    #     
    #     ofInterest=data[,c("county","year",index)]
    #     ofInterestC=subset(ofInterest,county==County)
    #     ofInterestC=ofInterestC[order(ofInterestC$year),]
    #     output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    #   })
    # })
  })
  
  
  output$fullMap3<- renderPlot({
    ##incorporate input$checkbox
    #Predictor=input$predictor
    #Response=input$response
    
    AGG=input$agg
    var=input$secStageVar
    
    ## means 3:18
    ## sd 19:34
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+18
    }
    
   # print(column)
  #  print(names(data3))
    ofInterest=data3[,c(column,1)]
    #print("here")
    #print(dim(ofInterest))
    # print(ofInterest)
    #print(class(ofInterest$year))
    #ofInterest=subset(ofInterest,year==Year)
    #print("here")
    #print(ofInterest)
    #print(ofInterest[,3])
    #cuts=factor(cut(ofInterest[,3],quantile(ofInterest[,3],seq(0,1,by=.1))))
    cuts=factor(cut2(ofInterest[,1],g=10))
    #print(levels(cuts))
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #print("here")
    labs <- levels(cuts)
    # cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
    # cutPoints=cbind(lower = as.numeric( sub("\\[[.+],.*", "\\1", labs) ),
    #                 upper = as.numeric( sub("(^,)*,[(^))*]\\)", "\\1", labs) ))
    Col=mypalette[cuts] 
    
    
    
    intermediate=unlist(lapply(levels(cuts),function(x){strsplit(sub("\\[","",x),",")[[1]][2]}))
    intermediate2=unlist(lapply(intermediate,function(x){sub(")","",x)}))
    cutPoints=as.numeric(unlist(lapply(intermediate2,function(x){sub("]","",x)})))
    # print(length(cutPoints))
    map('county', fill= TRUE, col =Col,mar=c(0,0,0,0))
    legend.gradient(cbind(x=c(-117,-115,-115,-117),y=c(30+.2,30+.2,25+.2,25+.2)), 
                    cols = c(brewer.pal(9, "OrRd"),"black"), title="", limits = "",cex=.75)
    #print(quantile(ofInterest[,1],seq(0,1,by=.1),na.rm=T))
    #print(dim(cutPoints))
    #text(-113,29.75+.1+.2,round(,2),cex=.75)
    text(-113,29.25+.1+.2+.5,round(cutPoints[10],2),cex=.75)
    text(-113,28.75+.1+.2+.5,round(cutPoints[9],2),cex=.75)
    text(-113,28.25+.1+.2+.5,round(cutPoints[8],2),cex=.75)
    text(-113,27.75+.1+.2+.5,round(cutPoints[7],2),cex=.75)
    text(-113,27.25+.1+.2+.5,round(cutPoints[6],2),cex=.75)
    text(-113,26.75+.1+.2+.5,round(cutPoints[5],2),cex=.75)
    text(-113,26.25+.1+.2+.5,round(cutPoints[4],2),cex=.75)
    text(-113,25.75+.1+.2+.5,round(cutPoints[3],2),cex=.75)
    text(-113,25.25+.1+.2+.5,round(cutPoints[2],2),cex=.75)
    text(-113,24.75+.1+.2+.5,round(cutPoints[1],2),cex=.75)
    
    #print("here")
  })
  
  
  
  output$byState3  <- renderPlot({
    
    ##incorporate input$checkbox
    
    st=input$state3
    
    AGG=input$agg2
    var=input$secStageVar2
    
    if(AGG==1){
      column=as.numeric(as.character(var))+2
    }else{
      column=as.numeric(as.character(var))+18
    }

  
    ofInterest=data3[,c(column,1,2)]
    #ofInterest=subset(ofInterest,year==Year)
    
    cutsOverall=factor(cut(ofInterest[,1],10))
    
    ## need way to get state
    ofInterestS=subset(ofInterest,state==st)
    cutsByState=factor(cut(ofInterestS[,1],10))
    
    ## just for now until the state issue is resolved
    #ofInterestS=cbind(rep(0,length(cutsOverall)),rep(0,length(cutsOverall)),rep(0,length(cutsOverall)))
    #cutsByState=rep(0,length(cutsOverall))
    
    ## quantile by state or quantile overall? make a button?
    ## 
    
    mypalette<-c(brewer.pal(9,"OrRd"),"black")
    #Col=mypalette[cutsOverall] 
    #Col=mypalette[cutsByState] 
    
    if(input$quant3==1){
      Col=mypalette[cutsOverall] 
      #leg=quantile(ofInterest[,3],seq(0,1,by=.1))
      
      labs <- levels(cutsOverall)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
      
    }else{
      Col=mypalette[cutsByState] 
      #leg=quantile(ofInterestS[,3],seq(0,1,by=.1))
      labs <- levels(cutsByState)
      cutPoints=cbind(lower = as.numeric( sub("\\((.+),.*", "\\1", labs) ),
                      upper = as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs) ))
      leg=cutPoints[,2]
    }
    
    
    map("county",st,col=Col,fill=T)
    legend("bottomleft", # position
           legend = leg, 
           fill = mypalette,
           cex = 0.56,
           bty = "n")
    # 
    # observe({
    #   if(is.null(input$plot_click$x)){return(NULL)}
    #   click <- c(input$plot_click$x, input$plot_click$y)
    #   latlong=cbind(as.numeric(click[1]),as.numeric(click[2]))
    #   County=latlong2county(latlong)
    #   
    #   
    #   isolate({
    #     Year=input$y ## use to subset data
    #     index=input$indic ## use to subset data
    #     
    #     ofInterest=data[,c("county","year",index)]
    #     ofInterestC=subset(ofInterest,county==County)
    #     ofInterestC=ofInterestC[order(ofInterestC$year),]
    #     output$click_info<-renderPlot({ plot(ofInterestC[,"year"],ofInterestC[,3],xlab="Year",type="l",main=County,ylab=index)})
    #   })
    # })
  })
  
  
  
  
  output$table <- renderTable({
    #data.frame(x=data())
  })
  output$table2 <- renderTable({
    #data.frame(x=data())
  })
  output$table3 <- renderTable({
    #data.frame(x=data())
  })
  
})